<!DOCTYPE html><!--  This site was created in Webflow. https://www.webflow.com  -->
<!--  Last Published: Mon Jul 17 2023 15:40:23 GMT+0000 (Coordinated Universal Time)  -->
<html data-wf-page="64b41eff30ae58c2d4ed5c70" data-wf-site="64b41eff30ae58c2d4ed5bfc">
<head>
  <meta charset="utf-8">
  <title>Shor&#x27;s Algorithm</title>
  <meta content="width=device-width, initial-scale=1" name="viewport">
  <meta content="Webflow" name="generator">
  <link href="css/normalize.css" rel="stylesheet" type="text/css">
  <link href="css/webflow.css" rel="stylesheet" type="text/css">
  <link href="css/shors-algo.webflow.css" rel="stylesheet" type="text/css">
  <link href="https://fonts.googleapis.com" rel="preconnect">
  <link href="https://fonts.gstatic.com" rel="preconnect" crossorigin="anonymous">
  <script src="https://ajax.googleapis.com/ajax/libs/webfont/1.6.26/webfont.js" type="text/javascript"></script>
  <script type="text/javascript">WebFont.load({  google: {    families: ["Gothic A1:300,regular,500,600,700,800"]  }});</script>
  <script type="text/javascript">!function(o,c){var n=c.documentElement,t=" w-mod-";n.className+=t+"js",("ontouchstart"in o||o.DocumentTouch&&c instanceof DocumentTouch)&&(n.className+=t+"touch")}(window,document);</script>
  <link href="images/favicon.ico" rel="shortcut icon" type="image/x-icon">
  <link href="images/webclip.png" rel="apple-touch-icon">
</head>
<body class="body">
  <div class="hero">
    <div data-collapse="medium" data-animation="default" data-duration="400" data-doc-height="1" data-easing="ease" data-easing2="ease" role="banner" class="nav w-nav">
      <div class="nav-inner">
        <div class="nav-logo-wrap">
          <a href="#" class="brand w-nav-brand">
            <div class="text-block-3">Shor&#x27;s Algorithm</div>
          </a>
        </div>
        <div class="nav-menu-wrap">
          <nav role="navigation" class="nav-menu-2 w-nav-menu">
            <a href="#introduction" class="nav-link w-nav-link">Introduction</a>
            <a href="#important_terms" class="nav-link w-nav-link">Important Terms</a>
            <a href="#process" class="nav-link w-nav-link">Process</a>
            <a href="#circuit" class="nav-link w-nav-link">Circuit</a>
            <a href="#simulation" class="nav-link w-nav-link">Simulation</a>
            <a href="#applications" class="nav-link w-nav-link">Applications</a>
            <a href="#conclusion" class="nav-link w-nav-link">Conclusion</a>
          </nav>
          <div class="menu-button w-nav-button">
            <div class="menu-icon w-icon-nav-menu"></div>
          </div>
        </div>
      </div>
    </div>
  </div>
  <div class="section center wf-section"><img src="images/arrow.svg" alt="" class="arrow">
    <div data-w-id="6b220cb1-4b9c-7fb0-75b9-53ff4a6c35a2" style="-webkit-transform:translate3d(0, 30PX, 0) scale3d(1, 1, 1) rotateX(0) rotateY(0) rotateZ(0) skew(0, 0);-moz-transform:translate3d(0, 30PX, 0) scale3d(1, 1, 1) rotateX(0) rotateY(0) rotateZ(0) skew(0, 0);-ms-transform:translate3d(0, 30PX, 0) scale3d(1, 1, 1) rotateX(0) rotateY(0) rotateZ(0) skew(0, 0);transform:translate3d(0, 30PX, 0) scale3d(1, 1, 1) rotateX(0) rotateY(0) rotateZ(0) skew(0, 0);opacity:0" class="hero-content">
      <h1 class="heading-3">Shor&#x27;s Algorithm</h1>
      <h3 class="hero-subhead">Quantum Breakthrough in Cybersecurity</h3>
    </div><img src="images/quantum-computer.jpeg" style="-webkit-transform:translate3d(0, 60PX, 0) scale3d(1, 1, 1) rotateX(0) rotateY(0) rotateZ(0) skew(0, 0);-moz-transform:translate3d(0, 60PX, 0) scale3d(1, 1, 1) rotateX(0) rotateY(0) rotateZ(0) skew(0, 0);-ms-transform:translate3d(0, 60PX, 0) scale3d(1, 1, 1) rotateX(0) rotateY(0) rotateZ(0) skew(0, 0);transform:translate3d(0, 60PX, 0) scale3d(1, 1, 1) rotateX(0) rotateY(0) rotateZ(0) skew(0, 0);opacity:0" data-w-id="77e69727-c455-8e07-0990-833a661c94ea" sizes="(max-width: 479px) 80vw, (max-width: 991px) 70vw, 99vw" srcset="images/quantum-computer-p-500.jpeg 500w, images/quantum-computer-p-800.jpeg 800w, images/quantum-computer.jpeg 960w" alt="" class="hero-image">
  </div>
  <div id="about" class="section wide img wf-section">
    <div data-w-id="b126983d-9126-fc06-c81d-1318685e2add" style="-webkit-transform:translate3d(0, 40PX, 0) scale3d(1, 1, 1) rotateX(0) rotateY(0) rotateZ(0) skew(0, 0);-moz-transform:translate3d(0, 40PX, 0) scale3d(1, 1, 1) rotateX(0) rotateY(0) rotateZ(0) skew(0, 0);-ms-transform:translate3d(0, 40PX, 0) scale3d(1, 1, 1) rotateX(0) rotateY(0) rotateZ(0) skew(0, 0);transform:translate3d(0, 40PX, 0) scale3d(1, 1, 1) rotateX(0) rotateY(0) rotateZ(0) skew(0, 0);opacity:0" class="wrap">
      <div id="introduction" class="title"><h2><strong>Introduction and Application</strong></h2></div>
      <div class="wrapper"></div>

      <h2></h2>
      <p class="paragraph-7">Are you tired of waiting ages for your computer to crack complex encryption codes? Well, get ready to be blown away by the mind-bending power of Shor&#x27;s algorithm! Picture this: a revolutionary mathematical wizardry that could potentially dismantle the unbreakable walls of modern cryptography in the blink of an eye. Strap in, because we&#x27;re about to embark on a mind-boggling journey through the cutting-edge realm of quantum computing, where Shor&#x27;s algorithm reigns supreme as the ultimate code-cracking superhero. Get ready to have your understanding of computational limits shattered as we dive into the enigmatic world of Shor&#x27;s algorithm and uncover its jaw-dropping implications for the future of security and cryptography.<br></p>
      <h2>A More Technical Definition</h2>
      <p class="paragraph-8">Shor&#x27;s algorithm is a groundbreaking mathematical method designed to solve a particular problem: factoring large numbers into their prime factors. It was invented by Peter Shor, a brilliant mathematician, and has become one of the most significant discoveries in the field of quantum computing. Here&#x27;s the gist of it: Traditional computers, like the ones we use every day, struggle to factor large numbers efficiently. This difficulty forms the basis of many encryption systems used to secure online transactions and protect sensitive information. Shor&#x27;s algorithm takes advantage of the unique properties of quantum computers, which operate using quantum bits, or qubits, instead of the classical bits of traditional computers. Qubits can exist in multiple states simultaneously, a phenomenon known as superposition, allowing quantum computers to perform certain calculations at an incredibly accelerated rate. By harnessing this power, Shor&#x27;s algorithm can rapidly find the prime factors of large numbers, a task that would take traditional computers an astronomical amount of time. This ability to factorize large numbers efficiently poses a significant threat to many encryption methods, as it could potentially render them vulnerable to attacks. In simpler terms, Shor&#x27;s algorithm is a quantum magic trick that enables computers to quickly unravel the secrets of large numbers, which has profound implications for breaking encryption codes and challenging the security of many systems that we rely on today.<br></p>


      <h2>Shor's vs Classical Algorithm</h2>
      <p class="paragraph-7">Shor's algorithm uses the quantum computing principles to run efficiently in polynomial time while the classical factorization can at best run at exponential time limiting the classical computer's powers. 
        The classical algorithms can factor numbers with at most with a few hundred digits. </p>
      <p class="paragraph-7"> The world record is d = 232, and this took roughly 2000 CPU years (approximately 17,520,000 normal years). 
        While in the graph, you can see that the Shor's algorithm has polynomial runtime of d^3.</p>
        <img src = "images/IMG_9394.jpg" alt = "Graph for Shor's vs Classical Algorithm">

      <h2 id="important_terms">Important Terms</h2>

      <p class="paragraph-7">Are you tired of waiting ages for your computer to crack complex encryption codes? Well, get ready to be blown away by the mind-bending power of Shor's algorithm! Picture this: a revolutionary mathematical algorithm that could potentially dismantle the walls of modern cryptography. Get ready to have your understanding of computational limits shattered as we dive into the enigmatic world of Shor's algorithm and uncover its jaw-dropping implications for the future of security and cryptography.
        Invented in 1994 by Peter Shor, Shor's algorithm is a groundbreaking mathematical method designed to solve a particular problem: factoring large numbers into their prime factors, something that mathematicians deemed impossible for a long time.<br></p>
      <p class="paragraph-8">Why is something as trivial as factoring numbers important? RSA encryption, the encryption methodology used by everyday web browsers, bank accounts, and essentially any link starting with “https://” is based on prime factorization.</p>
      
      <h2 id="important_terms">Important Terms</h2>
      <LI><h4>Quantum Computing:</h4>
        <UL TYPE="circle">
          <li>Quantum computing refers to a paradigm of computing that utilizes the principles of quantum mechanics to perform computational tasks. Unlike classical computers that use bits to represent and process information as either 0 or 1, quantum computers employ quantum bits or qubits.</li>
          <li>Qubits can exist in a superposition of states, enabling quantum computers to perform computations simultaneously on multiple states and potentially solve certain problems more efficiently than classical computers.</li>
      </UL>
      <LI><h4>Qubit:</h4>
        <UL TYPE="circle">
          <li>A qubit is the basic unit of information in quantum computing. It is analogous to a classical bit but represents a quantum system that can exist in a superposition of states, such as 0 and 1, allowing for simultaneous processing of multiple states.</li>
      </UL>
      <LI><h4>Superposition:</h4>
        <UL TYPE="circle">
          <li>Superposition is a fundamental concept in quantum mechanics. It refers to the property of a quantum system, such as a qubit, to exist in multiple states simultaneously. While classical bits can represent only one state at a time (either 0 or 1), a qubit in superposition can represent a combination of both states. This means that a qubit can be in a state that is a linear combination of 0 and 1, such as 0.5|0⟩ + 0.5|1⟩.</li>
          <li>Superposition allows quantum computers to perform parallel computations and explore multiple possibilities simultaneously, providing a potential computational advantage.</li>
      </UL>
      <LI><h4>Entanglement:</h4>
        <UL TYPE="circle">
          <li>Entanglement is a phenomenon that occurs when two or more qubits become correlated in such a way that the state of one qubit is dependent on the state of another, regardless of the distance between them. Once entangled, each qubit loses its individual state so that measuring one entangled qubit instantly provides information about the state of the other.</li>
          <li>Entanglement is a powerful resource in quantum computing and enables various applications such as quantum teleportation, quantum communication, and enhanced computational capabilities. It plays a crucial role in the potential speedup of certain algorithms in quantum computing.</li>
      </UL>
       
      <h2 id="process">Process</h2>
      <p class="paragraph-5"><strong>Shor&#x27;s algorithm involves several main steps to factorize a large number efficiently:<br></strong></p>
      <h3 class="heading-5"><strong>Initialization</strong></h3>
      <p class="paragraph-6">Start by preparing two sets of qubits: the control qubits and the target qubits. Initialize the control qubits to represent all possible values from 0 to (N-1), where N is the number to be factorized. Initialize the target qubits to a known state.<br></p>
      <h3 class="heading-5"><strong>Quantum Fourier Transform</strong></h3>
      <p class="paragraph-6">Apply the Quantum Fourier Transform to the control qubits. The QFT transforms the control qubits from a superposition of values into a superposition of frequency states, revealing the underlying periodicity in the quantum state.<br></p>
      <h3 class="heading-5"><strong>Modular Exponentiation</strong></h3>
      <p class="paragraph-6">Apply a modular exponentiation operation to the target qubits based on the value of the control qubits. This operation raises the target qubits to the power of the control qubits modulo N. It effectively computes a function of the form f(x) = a^x mod N, where a is a randomly chosen value.<br></p>
      <h3 class="heading-5"><strong>Quantum Measurement</strong></h3>
      <p class="paragraph-6">Perform a quantum measurement on the control qubits. The measurement collapses the superposition, providing a classical output that represents a periodic sequence derived from the quantum state. The measured values provide information related to the factors of the number N.<br></p>
      <h3 class="heading-5"><strong>Classical Post-processing</strong></h3>
      <p class="paragraph-6">Take the measurement results and perform classical post-processing. Analyze the measured periodic sequence to extract the period, which is crucial for factorization. This step typically involves applying number theory techniques such as continued fractions to approximate the period.<br></p>
      <h3 class="heading-5"><strong>Continued Fractions</strong></h3>
      <p class="paragraph-6">Use continued fraction expansion on the approximations obtained from the previous step to determine the period more accurately. Continued fractions provide rational approximations that reveal the periodic structure of the sequence.<br></p>
      <h3 class="heading-5"><strong>Greatest Common Divisor (GCD)</strong></h3>
      <p class="paragraph-6">Calculate the greatest common divisor (GCD) between the factors obtained from the continued fractions and the original number N. The GCD computation helps identify the prime factors of N.<br></p>
    <h3 class = "heading-5"> </h3>
    <p class = "paragraph-7">
      <h3>An example of Shor's Algorithm</h3>
    <p class = "paragraph-7">
     To factor an integer N = 21.<br><br>
     <span class = "step">Step-1:</span> Ensure that the number N is not prime, even or an integer power of prime which can be done using classical methods.
<br> <br><span class = "step">Step-2:</span>  Choose an integer 'q' between N^2 < q < 2N^2. (q = 512)
<br> <br><span class = "step">Step-3:</span>  Pick a random integer x where GCD(x, N) = 1. (x = 11)
<br> <br><span class = "step">Step-4:</span>  Then, we create 2 entangled quantum registers:<br>
<strong>1. Input Register -</strong> containing sufficient qubits for representing numbers as big as q -1. <br>(Here, q - 1 = 511 => 9 qubits needed)
<br><strong>2. Output Register - </strong>containing sufficient qubits for representing numbers as big as N-1. <br>(Here, N - 1 = 20 => 5 qubits needed)
<br> <br><span class = "step">Step-5:</span>  Load the input register with an equally weighed superposition of integers from 0 to q-1. (0 to 511)
<br> <br><span class = "step">Step-6:</span>  Load the output register with zeros.
The total state of the system is  <img class = "stepsImages"src="images/SAstep-6.jpg" alt = "state of the system">

<br> <br><span class = "step">Step-7:</span>  Apply the transformation - "x^a mod N" to each number in input register and store the result in output register.
<br><br><img src = "images/TableForExample.jpg" class="TableForExample" alt=" Table ">
<br> <br><span class = "step">Step-8:</span>  After measuring the output register, it will collapse to 1 result of the transformation 'c' out of 1, 11, 16, 8, 4, and 2 here. 
<br>Let's select c = 1.
<br> <br><span class = "step">Step-9:</span>   As the 2 registers are entangled, measuring the output register will partially collapse the input register into an equal superposition of each state between 0 and q-1 that yielded c => All numbers 'y' such that 11^y Mod 21 = 1.
<br>Then the input register's state is[(1/√86) |0> + (1/√86) |6> + (1/√86) |12> + (1/√86) |18> + (1/√86) |24> + .... ].
<br> The probabilities here are (1/√86) as our register is in an equal superposition of 86 values which are 0, 6, 12, ..., 510.
<br> <br><span class = "step">Step-10:</span>  We then apply Quantum Fourier Transform (QFT) on the input register. The QFT takes a state |a> and transforms it into a state :
<img class = "stepsImages1"src="images/SAstep10jpg.jpg" alt = "state of the system">
<br>
<br> <br><span class = "step">Step-11:</span>  After doing the computations with the values y that yield 11^y Mod 21 = 1, we obtain the final state of the input register to be
<img class = "stepsImages2"src="images/SAstep11jpg.jpg" alt = "state of the system">
<br>
<br> <br><span class = "step">Step-12:</span> The QFT will peak the probability amplitudes at the integer multiples of (q/r) i.e. 512/6 as here r is the desired period which is 6 in this case. 
<br>Thus, the peak probability will be at |85.33>, |170.66>, |256>, .....
<br>As a result, we do not have an equal superposition of states, and the probability amplitudes of above states are now higher than the other states.
<br> <br><span class = "step">Step-13:</span>  Then, we measure the state 'm' of register one and with help of q and m, we calculate the period using continuous fraction expansion of the raito of q and m.
<br> <br><span class = "step">Step-14:</span>  Finally, using the period (P), we calculate the factors of N by taking the GCD of each x^(P/2) + 1 and x^(p/2) - 1 with N using a classical computer. <br>In our case, P = 6 and the factors are : GCD(11^(6/2) +1, 21) = 3 and GCD(11^(6/2) - 1, 21) = 7.


    </p>
  </p>
    </div>
  </div>
  <div class="section wf-section">



 
    
 
    <head>
      <title>Interactive Kernel</title>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/brython/3.9.12/brython.min.js"></script>
    </head>
    <body onload="brython()">
      <section id="input"> 
        <div id="simulation" class="title">Simulation</div>
        <div class="html-embed w-embed w-script">
          <h2>Algorithm Demonstration</h2>
          
          <!-- Step 1 comprises the beginning classical steps of Shor's 
          initialize N and a, explain modular exponentiation at its core and output a graph of the modulus vs number of modular steps-->
          
          <h4>Step 1: Initialization</h4>
          <p> N represents the number we want to factor. For Shor's algorithm to properly function, the number we want to factor must satisfy two conditions:</p>
          
          <!-- List of requirements for N (bullet points) -->
          <ul style="list-style-type:circle">
            <li>N is composite (not prime)</li>
            <li>N is not a power of a prime number</li>
          </ul>
          
          <textarea id="code-editor"></textarea>
          
          <button onclick="runCode()">Run Code</button>
        </div>
        <div data-w-id="d5ba5e87-b9ed-633f-6f62-a83bb76a24a6" style="-webkit-transform:translate3d(0, 40PX, 0) scale3d(1, 1, 1) rotateX(0) rotateY(0) rotateZ(0) skew(0, 0);-moz-transform:translate3d(0, 40PX, 0) scale3d(1, 1, 1) rotateX(0) rotateY(0) rotateZ(0) skew(0, 0);-ms-transform:translate3d(0, 40PX, 0) scale3d(1, 1, 1) rotateX(0) rotateY(0) rotateZ(0) skew(0, 0);transform:translate3d(0, 40PX, 0) scale3d(1, 1, 1) rotateX(0) rotateY(0) rotateZ(0) skew(0, 0);opacity:0" class="wrap">
          <div id="circuit" class="title">circuit</div>
        </div>
        <h2>Shor's Circuit</h2>
        <p class="paragraph-3">Below is the general layout of a quantum circuit that calculates Shor's algorithm.</p>
        <p>Click on the circuit to know more</p>
        <div id="features" class="feature-wrap">
          <div>
            <div data-w-id="4593c4b7-56e8-060a-be57-648b0e08fc65" style="-webkit-transform:translate3d(0, 40PX, 0) scale3d(1, 1, 1) rotateX(0) rotateY(0) rotateZ(0) skew(0, 0);-moz-transform:translate3d(0, 40PX, 0) scale3d(1, 1, 1) rotateX(0) rotateY(0) rotateZ(0) skew(0, 0);-ms-transform:translate3d(0, 40PX, 0) scale3d(1, 1, 1) rotateX(0) rotateY(0) rotateZ(0) skew(0, 0);transform:translate3d(0, 40PX, 0) scale3d(1, 1, 1) rotateX(0) rotateY(0) rotateZ(0) skew(0, 0);opacity:0" class="feature-content"></div>
          </div>
          <div class="feature-image"></div>
          
        </div><a href="circuit.html" target ="blank"><img  src="images/shorcircuit.png" width="1074" sizes="100vw" srcset="images/shorcircuit-p-500.png 500w, images/shorcircuit-p-800.png 800w, images/shorcircuit-p-1080.png 1080w, images/shorcircuit.png 1129w" alt="" class="image-2"></a>
        <div class="feature-wrap reverse">
          <div data-w-id="cafe0045-d304-79d9-8f68-af3adaed06e9" style="-webkit-transform:translate3d(0, 40PX, 0) scale3d(1, 1, 1) rotateX(0) rotateY(0) rotateZ(0) skew(0, 0);-moz-transform:translate3d(0, 40PX, 0) scale3d(1, 1, 1) rotateX(0) rotateY(0) rotateZ(0) skew(0, 0);-ms-transform:translate3d(0, 40PX, 0) scale3d(1, 1, 1) rotateX(0) rotateY(0) rotateZ(0) skew(0, 0);transform:translate3d(0, 40PX, 0) scale3d(1, 1, 1) rotateX(0) rotateY(0) rotateZ(0) skew(0, 0);opacity:0" class="feature-content"></div>
          <div class="feature-image"></div>
        </div>
      </section>
      
      
      <script>
        function runCode() {
          const code = document.getElementById("code-editor").value;
          
          try {
            // Execute the code here
            const output = BrythonRunner.run(code);
            console.log(output);
          } catch (error) {
            console.error(error);
          }
        }
      </script>
    </body>
   
    



    

   

    
    


    

    <section id="classicalOutput">
      <h4>Step 2: Modular Exponentiation & Period Finding</h4>
      <p>After initializing N and a, we find the greatest common divisor (gcd) of a and N</p>
      <p> We use Euclid's algorithm to calculate gcd(a,N) and so use the formula f(x) = a^x mod N</p>
      <p> If a^1 mod N = 1, then a is a factor of N and we are done! Although, if not, we will continue this process until gcd(a,N) = 1</p>
      <button onclick="calculate()">Calculate</button>
      <p id="result"></p>
    </section>
    <section id="quantumOutput">

    </section>


<script>
function calculate() {
  var N = document.getElementById("N").value;
  var a = document.getElementById("a").value;
  // Find the period
  var r = findPeriod(a, N);
  // Calculate p and q
  var p = gcd(Math.pow(a, r/2) + 1, N);
  var q = gcd(Math.pow(a, r/2) - 1, N);
  var stepStr = "Let N = " + N + ", a = " + a + ", and r = " + r + ". <br>";
  stepStr += "We can find that a^r = " + Math.pow(a, r) + " mod " + N + " = 1. <br>";
  stepStr += "Then, we calculate (a^(r/2) + 1) = " + (Math.pow(a, r/2) + 1) + " and (a^(r/2) - 1) = " + (Math.pow(a, r/2) - 1) + ". <br>";
  stepStr += "The greatest common divisor of (a^(r/2) + 1) and N is " + p + ", and for (a^(r/2) - 1) and N is " + q + ". <br>";
  stepStr += "So, the factors of " + N + " are " + p + " and " + q + ".";
  document.getElementById("result").innerHTML = stepStr;
}
// Helper function to calculate the period
function findPeriod(a, N) {
  var val = a;
  var r = 1;
  while (val % N != 1) {
    val = (val * a) % N;
    r++;
  }
  return r;
}
// Helper function to calculate the greatest common divisor (gcd)
function gcd(a, b) {
  if (b == 0) {
    return a;
  } else {
    return gcd(b, a % b);
  }
}
//computes the fourier tranform on an array 'reg'
//returns the powers of the result, which is enough for finding the dominant frequency/period
//this is a naive algorithm i know
function fourier(reg,size) {
	var freq = new Array(size);
	for( var i = 0; i < size; i++ ) {
		var n = new Complex(0,0);
		for( var j = 0; j < size; j++) {
			n.a += reg[j]*Math.cos(-2*Math.PI*i*j/size);
			n.b += reg[j]*Math.sin(-2*Math.PI*i*j/size);
		}
		freq[i] = n.power();
	}
	return freq;
}

//represents a complex number , a + bi
var Complex = Class.create({
	initialize: function (a,b) {
		this.a = a;
		this.b = b;
	},
	//returns magnitude on the complex plane
	magnitude: function () {
		return Math.sqrt(this.a*this.a + this.b*this.b);
	},
	//square of magnitude
	power: function () {
		return (this.a*this.a + this.b*this.b);
	}
});


//represents a quantum register of 'size' qubits
var QReg = Class.create({
	initialize: function (size) {
		this.size = size;
		//probability of each
		//possible state of the qubits
		this.states = Math.pow(2,size);
		this.probs = new Array(this.states);
		for( var i = 0; i < this.states; i++ ) {
			//initializes probabilities equally
			this.probs[i] = 1;
		}
		this.normalize(); 
		//at this point, measuring the value of QReg
		//would return a random value between 0 and size-1
	},
	//collapses the register and returns 
	//the decimal value of the measured number
	measure: function () {
		var rand = Math.random(); //random 0 <= r < 1
		var pLess = 0; //stores the probability that we read less than probs[i]
		var pMore = 0; //stores the probability that we read more than probs[i]
		
		//check all probabilities and see if the random number chosen fits in the 'slot' of the given 'i'
		for( var i = 0; i < this.states; i++ ) {
			pMore += this.probs[i];
			if( rand > pLess && rand < pMore ) {
				//kay, we're measuring this one
				//collapse state of everything else
				for( var j = 0; j < this.states; j++ ) {
					this.probs[j] = (j === i ? 1 : 0); 
				}
				//return read value
				return i;
			}
			pLess += this.probs[i];
		}
		//uhoh, an error
		return -1; 
	},
	//returns new register transformed throguh
	//a^x mod n, x represented by the superposition of states
	//in this register
	modTransform: function (a,n) {
		var out = new QReg(this.size);
		//set output register to 0 first
		for( var i = 0; i < this.states; i++ ) {
			out.probs[i] = 0;
		}
		//classically calculate the a^x mod n for every
		//possible state, and increment the probability
		//for the result in the new register with the probability
		//of getting that number from this register
		for( var i = 0; i < this.states; i++ ) {
			var result = expmod(a,i,n);
			out.probs[result] += this.probs[i];
		}
		out.normalize();
		//out now represents the superposition 
		//of all possible outputs of a^x mod n
		return out;
		//the quantum register 'out' is entangled with this register
		//so a measurement on 'out' also collapses positions of
		//this register inconsistent with the measurement
		//I couldn't think of a nice OOP way to handle that
		//so the makeConsistent function makes the current register
		//consistent with whatever the input measurement is
	},
	//makes this register's superposition consistent with
	//the measurement from the register returned by the 'modTransform'
	//function with base 'a' and mod 'n'
	makeConsistent: function (a,n,measured) {
		//for each possible state, we need to calculate
		//a^X mod n again, and set the probability
		//of that state accordingly
		for( var i = 0; i < this.states; i++ ) {
			var result = expmod(a,i,n);
			//if result equals the value measured, this value would occur
			this.probs[i] = ( result === measured ? 1 : 0 );
		}
		this.normalize();
	},
	//normalizes the register so the total probablity is 1
	normalize: function () {
		//find current total
		var total = 0;
		for( var i = 0; i < this.states; i++ ) {
			total += this.probs[i];
		}
		//find scaling factor to reduce total to 1
		//and apply it to all the states
		var scale = 1.0 / total;
		for( var i = 0; i < this.states; i++ ) {
			this.probs[i] *= scale;
		}
	},
	//returns a new QReg containing the amplitudes of the quantum transform
	//of this QReg
	quantFT: function () {
		//perform regular ol' DFT on the probabilities
		//of this register
		var result = fourier(this.probs,this.states);
		var newReg = new QReg(this.size);
		//set the probabilities of newReg to the fourier transform
		newReg.probs = result;
		newReg.normalize();
		//newReg now will return a k*this.states/period, where k is
		//random between 0 < r <= r-1
		return newReg;
	},
	//graphs the pdf of this register 
	//using Plotr, to element 'e'
	//with max being the max on the x-axis
	//drawTicks is bool on whether to draw ticks
	graph: function(e, max, drawTicks) {
		//form probabilities
		var pdf = new Array();
		var ticks = new Array();
		for( var i = 0; i < this.states; i++ ) {
			pdf.push([i, this.probs[i]]);
			if( i < max ) { ticks.push(i) }
		}
		if( !drawTicks ) ticks = null;
		Flotr.draw(
			e, 
			[ pdf ],
			{	
				mouse:{
					track: true,
					color: 'purple',
					sensibility: 1, // => distance to show point get's smaller
					trackDecimals: 4,
					trackFormatter: function(obj){ return 'x = ' + obj.x +', y = ' + obj.y; }
				},
				yaxis: {
					min: 0, max: null
				},
				xaxis: {
					ticks: ticks,
					min: 0, max: max
				},
				points: {
					show: true
				}
			}
		);
	}
});
</script>
    </div>
  </div>
  <div class="bottom-image-wrap"></div>
  <div class="section wide purple wf-section">
    <div data-w-id="dd4fef5a-896f-8941-4cbb-93e2b3074e5f" style="-webkit-transform:translate3d(0, 40PX, 0) scale3d(1, 1, 1) rotateX(0) rotateY(0) rotateZ(0) skew(0, 0);-moz-transform:translate3d(0, 40PX, 0) scale3d(1, 1, 1) rotateX(0) rotateY(0) rotateZ(0) skew(0, 0);-ms-transform:translate3d(0, 40PX, 0) scale3d(1, 1, 1) rotateX(0) rotateY(0) rotateZ(0) skew(0, 0);transform:translate3d(0, 40PX, 0) scale3d(1, 1, 1) rotateX(0) rotateY(0) rotateZ(0) skew(0, 0);opacity:0" class="wrap">
      <h2 id="applications">Applications</h2>
      <div class="button-wrap"></div>
      <p class="paragraph-2">The primary application of Shor&#x27;s algorithm lies in its potential to break the widely used public-key encryption schemes based on the difficulty of factoring large numbers. By efficiently factoring large numbers, Shor&#x27;s algorithm poses a significant threat to the security of these encryption schemes. Public-key encryption is a crucial component of modern secure communication, including online transactions, data protection, and secure messaging. It relies on the fact that factoring large numbers into their prime factors is computationally hard for classical computers. However, Shor&#x27;s algorithm, when executed on a powerful enough quantum computer, has the potential to factorize these numbers efficiently, undermining the security provided by such encryption schemes. If Shor&#x27;s algorithm becomes practically implementable on a large-scale, it could compromise the security of widely adopted encryption algorithms like the RSA (Rivest-Shamir-Adleman) and elliptic curve cryptography (ECC). This would necessitate the development and adoption of new cryptographic systems resistant to attacks from quantum computers, such as post-quantum cryptography. Apart from breaking encryption, Shor&#x27;s algorithm has implications in other areas of computation as well. It provides a demonstration of the power of quantum computing to solve certain mathematical problems more efficiently than classical computers. This, in turn, can contribute to advances in fields like optimization, simulation, and solving mathematical equations, where the factorization problem is an important subroutine. While the practical implementation of Shor&#x27;s algorithm on a large-scale quantum computer is still a significant technological challenge, its potential impact on encryption and computational fields makes it a subject of intense research and development. Researchers are actively exploring quantum-resistant cryptographic techniques and working towards the realization of practical quantum computers to harness the power of Shor&#x27;s algorithm and develop secure cryptographic systems for the future.<br><br></p>
    </div>
    <div data-w-id="376e2a1f-ec70-0dab-11ea-b1863101e37b" style="-webkit-transform:translate3d(0, 40PX, 0) scale3d(1, 1, 1) rotateX(0) rotateY(0) rotateZ(0) skew(0, 0);-moz-transform:translate3d(0, 40PX, 0) scale3d(1, 1, 1) rotateX(0) rotateY(0) rotateZ(0) skew(0, 0);-ms-transform:translate3d(0, 40PX, 0) scale3d(1, 1, 1) rotateX(0) rotateY(0) rotateZ(0) skew(0, 0);transform:translate3d(0, 40PX, 0) scale3d(1, 1, 1) rotateX(0) rotateY(0) rotateZ(0) skew(0, 0);opacity:0" class="wrap">
      <h2 id="conclusion">Conclusion</h2>
      <div class="button-wrap"></div>
      <p class="paragraph-2">In conclusion, Shor&#x27;s algorithm is a groundbreaking mathematical algorithm in the field of quantum computing. It has the potential to break widely used public-key encryption schemes by efficiently factoring large numbers into their prime factors. By leveraging the unique properties of quantum computers, such as superposition and quantum Fourier transforms, Shor&#x27;s algorithm can solve the factorization problem at an accelerated rate compared to classical computers. The application of Shor&#x27;s algorithm raises significant concerns for the security of current encryption methods, which form the backbone of secure communication, online transactions, and data protection. If practical quantum computers capable of executing Shor&#x27;s algorithm are realized, it could render widely adopted encryption schemes vulnerable to attacks. The development and implementation of post-quantum cryptography, which focuses on designing encryption algorithms resistant to quantum attacks, have become crucial in light of Shor&#x27;s algorithm. Researchers and organizations are actively exploring alternative encryption schemes that can withstand attacks from quantum computers. Moreover, Shor&#x27;s algorithm showcases the immense potential of quantum computing beyond encryption breaking. It demonstrates the ability of quantum computers to solve certain mathematical problems more efficiently, offering promising applications in fields like optimization, simulation, and mathematical equation solving. Although practical implementation of Shor&#x27;s algorithm on large-scale quantum computers remains a significant technological challenge, its implications have ignited intensive research and development efforts in quantum computing, cryptography, and related fields. As the race towards building practical quantum computers continues, the impact of Shor&#x27;s algorithm on the future of encryption and computational fields remains a topic of great significance and exploration.<br></p>
    </div>
  </div>
  <div class="footer wf-section">
    <div class="wrap"></div>
  </div>
  <script src="https://d3e54v103j8qbb.cloudfront.net/js/jquery-3.5.1.min.dc5e7f18c8.js?site=64b41eff30ae58c2d4ed5bfc" type="text/javascript" integrity="sha256-9/aliU8dGd2tb6OSsuzixeV4y/faTqgFtohetphbbj0=" crossorigin="anonymous"></script>
  <script src="js/webflow.js" type="text/javascript"></script>
</body>
</html>